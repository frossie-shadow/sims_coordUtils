"""
This unit test compares the outputs of the PALPY driven Astrometry
routines with outputs generated by the same routines powered by
pySLALIB v 1.0.2

There will be some difference, as the two libraries are based on slightly
different conventions (for example, the prenut routine which calculates
the matrix of precession and nutation is based on the IAU 2006/2000A
standard in PALPY and on SF2001 in pySLALIB; however, the two outputs
still agree to within one part in 10^5)

To recreate test data, install pyslalib from

https://git@github.com:/scottransom/pyslalib

include the line

from pyslalib import slalib as sla

at the top of

/lsst/sims/catalogs/measures/astrometry/Astrometry.py

and then replace all occurrences of

pal.medthodName(args)

with

sla.sla_methodName(args)

"""

import numpy

import os
import unittest
import warnings
import sys
import math
import palpy as pal
from collections import OrderedDict
import lsst.utils.tests as utilsTests

import lsst.afw.geom as afwGeom
from lsst.sims.catalogs.measures.instance import InstanceCatalog
from lsst.sims.catalogs.generation.db import ObservationMetaData
from lsst.sims.utils import getRotTelPos, altAzToRaDec, calcObsDefaults, \
                            arcsecToRadians, radiansToArcsec, Site
from lsst.sims.coordUtils.Astrometry import AstrometryBase, AstrometryStars, CameraCoords
from lsst.sims.catalogs.generation.utils import myTestStars, makeStarTestDB
import lsst.afw.cameraGeom.testUtils as camTestUtils

def makeObservationMetaData():
    #create a cartoon ObservationMetaData object
    mjd = 52000.0
    alt = numpy.pi/2.0
    az = 0.0
    band = 'r'
    testSite = Site(latitude=0.5, longitude=1.1, height=3000, meanTemperature=260.0,
                    meanPressure = 725.0, lapseRate=0.005)
    centerRA, centerDec = altAzToRaDec(alt,az,testSite.longitude,testSite.latitude,mjd)
    rotTel = getRotTelPos(centerRA, centerDec, testSite.longitude, testSite.latitude, mjd, 0.0)

    obsDict = calcObsDefaults(centerRA, centerDec, alt, az, rotTel, mjd, band,
                 testSite.longitude, testSite.latitude)

    obsDict['Opsim_expmjd'] = mjd
    radius = 0.1
    phoSimMetaData = OrderedDict([
                      (k, (obsDict[k],numpy.dtype(type(obsDict[k])))) for k in obsDict])

    obs_metadata = ObservationMetaData(boundType = 'circle', boundLength = 2.0*radius,
                                       phoSimMetaData=phoSimMetaData, site=testSite)

    return obs_metadata

def makeRandomSample(raCenter=None, decCenter=None, radius=None):
    #create a random sample of object data

    nsamples=100
    numpy.random.seed(32)

    if raCenter is None or decCenter is None or radius is None:
        ra = numpy.random.sample(nsamples)*2.0*numpy.pi
        dec = (numpy.random.sample(nsamples)-0.5)*numpy.pi
    else:
        rr = numpy.random.sample(nsamples)*radius
        theta = numpy.random.sample(nsamples)*2.0*numpy.pi
        ra = raCenter + rr*numpy.cos(theta)
        dec = decCenter + rr*numpy.cos(theta)

    pm_ra = (numpy.random.sample(nsamples)-0.5)*0.1
    pm_dec = (numpy.random.sample(nsamples)-0.5)*0.1
    parallax = numpy.random.sample(nsamples)*0.01
    v_rad = numpy.random.sample(nsamples)*1000.0

    return ra, dec, pm_ra, pm_dec, parallax, v_rad

class AstrometryTestStars(myTestStars):
    database = 'AstrometryTestDatabase.db'

class parallaxTestCatalog(InstanceCatalog, AstrometryStars):
    column_outputs = ['raJ2000', 'decJ2000', 'raObserved', 'decObserved',
                      'properMotionRa', 'properMotionDec',
                      'radialVelocity', 'parallax']

    transformations = {'raJ2000':numpy.degrees, 'decJ2000':numpy.degrees,
                       'raObserved':numpy.degrees, 'decObserved':numpy.degrees,
                       'properMotionRa':numpy.degrees, 'properMotionDec':numpy.degrees,
                       'parallax':radiansToArcsec}

    default_formats = {'f':'%.12f'}

class testCatalog(InstanceCatalog,AstrometryStars,CameraCoords):
    """
    A (somewhat meaningless) instance catalog class that will allow us
    to run the astrometry routines for testing purposes
    """
    catalog_type = 'test_stars'
    column_outputs=['id','raPhoSim','decPhoSim','raObserved','decObserved',
                   'x_focal_nominal', 'y_focal_nominal', 'x_pupil','y_pupil',
                   'chipName', 'xPix', 'yPix','xFocalPlane','yFocalPlane']
    #Needed to do camera coordinate transforms.
    camera = camTestUtils.CameraWrapper().camera
    default_formats = {'f':'%.12f'}

    delimiter = ';' #so that numpy.loadtxt can parse the chipNames which may contain commas
                     #(see testClassMethods)

    default_columns = [('properMotionRa', 0., float),
                       ('properMotionDec', 0., float),
                       ('parallax', 1.2, float),
                       ('radial_velocity', 0., float)]


class astrometryUnitTest(unittest.TestCase):
    """
    The bulk of this unit test involves inputting a set list of input values
    and comparing the astrometric results to results derived from SLALIB run
    with the same input values.  We have to create a test catalog artificially (rather than
    querying the database) because SLALIB was originally run on values that did not correspond
    to any particular Opsim run.
    """

    @classmethod
    def setUpClass(cls):
        # Create test databases
        if os.path.exists('AstrometryTestDatabase.db'):
            print "deleting database"
            os.unlink('AstrometryTestDatabase.db')
        makeStarTestDB(filename='AstrometryTestDatabase.db',
                      size=100000, seedVal=1, ramin=199.98*math.pi/180., dra=0.04*math.pi/180.)

    @classmethod
    def tearDownClass(cls):
        if os.path.exists('AstrometryTestDatabase.db'):
            os.unlink('AstrometryTestDatabase.db')

    def setUp(self):
        self.starDBObject = AstrometryTestStars()
        self.metadata={}

        #below are metadata values that need to be set in order for
        #get_skyToFocalPlane to work.  If we had been querying the database,
        #these would be set to meaningful values.  Because we are generating
        #an artificial set of inputs that must comport to the baseline SLALIB
        #inputs, these are set arbitrarily by hand
        self.metadata['Unrefracted_RA'] = (numpy.radians(200.0), float)
        self.metadata['Unrefracted_Dec'] = (numpy.radians(-30.0), float)
        self.metadata['Opsim_rotskypos'] = (1.0, float)

        self.obs_metadata=ObservationMetaData(mjd=50984.371741,
                                     boundType='circle',
                                     boundLength=0.05,
                                     phoSimMetaData=self.metadata)

        self.cat = testCatalog(self.starDBObject, obs_metadata=self.obs_metadata)
        self.tol=1.0e-5

    @classmethod
    def tearDownClass(cls):
        if os.path.exists('AstrometryTestDatabase.db'):
            os.unlink('AstrometryTestDatabase.db')

    def tearDown(self):
        del self.starDBObject
        del self.cat
        del self.obs_metadata
        del self.metadata
        del self.tol

    def isNanOrNone(self, value):
        """
        Returns True if value is None or nan.  False otherwise.
        """

        if value is None:
           return True

        try:
            if numpy.isnan(value):
                return True
        except TypeError:
            pass

        return False

    def compareTestControlAndWrong(self, test, control, wrong):
        """
        param [in] test is an array

        param [in] control is an array

        param [in] wrong is an array

        This method verifies that test and control are identical and that test
        and wrong are not
        """

        for (tt, cc, ww) in zip(test, control, wrong):
            if '__iter__' in dir(tt):
                for (t, c, w) in zip(tt, cc, ww):
                    if not self.isNanOrNone(t):
                        self.assertEqual(t, c)
                    else:
                        self.assertTrue(self.isNanOrNone(c))

                    if not self.isNanOrNone(t) or not self.isNanOrNone(w):
                        self.assertNotEqual(t, w)
            else:
                if not self.isNanOrNone(tt):
                    self.assertEqual(tt, cc)
                else:
                    self.assertTrue(self.isNanOrNone(cc))

                if not self.isNanOrNone(tt) or not self.isNanOrNone(ww):
                    self.assertNotEqual(tt, ww)

    def testWritingOfCatalog(self):
        self.cat.write_catalog("starsTestOutput.txt")
        os.unlink("starsTestOutput.txt")

    def testAstrometryExceptions(self):
        """
        Test to make sure that stand-alone astrometry methods raise an exception when they are called without
        the necessary arguments
        """
        obs_metadata = makeObservationMetaData()
        ra, dec, pm_ra, pm_dec, parallax, v_rad = makeRandomSample()
        myAstrometry = AstrometryBase()

        raShort = numpy.array([1.0])
        decShort = numpy.array([1.0])

        self.assertRaises(RuntimeError, myAstrometry.refractionCoefficients)
        site = obs_metadata.site
        x, y = myAstrometry.refractionCoefficients(site=site)

        self.assertRaises(RuntimeError, myAstrometry.calculateGnomonicProjection, ra, dec)
        self.assertRaises(RuntimeError, myAstrometry.calculateGnomonicProjection, ra, dec, obs_metadata=obs_metadata)
        self.assertRaises(RuntimeError, myAstrometry.calculateGnomonicProjection, ra, dec, epoch=2000.0)
        dummy_obs_metadata = ObservationMetaData(unrefractedDec=25.0, rotSkyPos=10.0, mjd=50984.371741)
        self.assertRaises(RuntimeError, myAstrometry.calculateGnomonicProjection, ra, dec, epoch=2000.0, obs_metadata=dummy_obs_metadata)
        dummy_obs_metadata = ObservationMetaData(unrefractedRA=25.0, rotSkyPos=10.0, mjd=50984.371741)
        self.assertRaises(RuntimeError, myAstrometry.calculateGnomonicProjection, ra, dec, epoch=2000.0, obs_metadata=dummy_obs_metadata)
        dummy_obs_metadata = ObservationMetaData(unrefractedRA=25.0, unrefractedDec=25.0, rotSkyPos=10.0)
        self.assertRaises(RuntimeError, myAstrometry.calculateGnomonicProjection, ra, dec, epoch=2000.0, obs_metadata=dummy_obs_metadata)

        myAstrometry.calculateGnomonicProjection( numpy.array([numpy.radians(obs_metadata.unrefractedRA)]),
                                                  numpy.array([numpy.radians(obs_metadata.unrefractedDec)]),
                                                  epoch=20000.0, obs_metadata=obs_metadata)

        xGnomon, yGnomon = myAstrometry.calculateGnomonicProjection(numpy.array([numpy.radians(obs_metadata.unrefractedRA)+0.01]),
                                                                    numpy.array([numpy.radians(obs_metadata.unrefractedDec)+0.1]),
                                                                     epoch=2000.0, obs_metadata=obs_metadata)

        self.assertRaises(RuntimeError, myAstrometry.applyMeanApparentPlace, ra, dec)
        self.assertRaises(RuntimeError, myAstrometry.applyMeanApparentPlace, ra, decShort)
        self.assertRaises(RuntimeError, myAstrometry.applyMeanApparentPlace, raShort, dec)
        test=myAstrometry.applyMeanApparentPlace(ra, dec, MJD=obs_metadata.mjd)

        self.assertRaises(RuntimeError, myAstrometry.applyMeanObservedPlace, ra, dec)
        dummy_obs_metadata = ObservationMetaData(mjd=5389.0, boundType = 'circle', boundLength = 0.2, site=None, phoSimMetaData=self.metadata)
        self.assertRaises(RuntimeError, myAstrometry.applyMeanObservedPlace, ra, dec, obs_metadata=dummy_obs_metadata)
        test = myAstrometry.applyMeanObservedPlace(ra, dec, obs_metadata=obs_metadata)

        self.assertRaises(RuntimeError, myAstrometry.correctCoordinates, ra, dec, obs_metadata=obs_metadata)
        self.assertRaises(RuntimeError, myAstrometry.correctCoordinates, ra, dec, epoch=2000.0)

        dummy_obs_metadata = ObservationMetaData(boundType = 'circle', boundLength = 0.2, site=None, phoSimMetaData=self.metadata)
        self.assertRaises(RuntimeError, myAstrometry.correctCoordinates, ra, dec, epoch=2000.0,
                          obs_metadata=dummy_obs_metadata)

        test = myAstrometry.correctCoordinates(ra, dec, obs_metadata=obs_metadata, epoch=2000.0)

        self.assertRaises(RuntimeError, myAstrometry.calculatePupilCoordinates, ra, dec,
                          obs_metadata=obs_metadata)
        self.assertRaises(RuntimeError, myAstrometry.calculatePupilCoordinates, ra, dec,
                          epoch=2000.0)

        dummy_obs_metadata = ObservationMetaData(rotSkyPos=10.0, unrefractedDec=10.0, mjd=51200.0)
        self.assertRaises(RuntimeError, myAstrometry.calculatePupilCoordinates, ra, dec,
                          epoch=2000.0, obs_metadata=dummy_obs_metadata)

        dummy_obs_metadata = ObservationMetaData(rotSkyPos=10.0, unrefractedRA=10.0, mjd=51200.0)
        self.assertRaises(RuntimeError, myAstrometry.calculatePupilCoordinates, ra, dec,
                          epoch=2000.0, obs_metadata=dummy_obs_metadata)

        dummy_obs_metadata = ObservationMetaData(unrefractedRA=10.0, unrefractedDec=10.0, rotSkyPos=10.0)
        self.assertRaises(RuntimeError, myAstrometry.calculatePupilCoordinates, ra, dec,
                          epoch=2000.0, obs_metadata=dummy_obs_metadata)

        test = myAstrometry.calculatePupilCoordinates(ra, dec, obs_metadata=obs_metadata, epoch=2000.0)

    def testCameraCoordsExceptions(self):
        """
        Test to make sure that focal plane methods raise exceptions when coordinates are improperly
        specified.
        """

        #these are just values shown heuristically to give an actual chip name
        ra = numpy.array([numpy.radians(self.obs_metadata.unrefractedRA) - 1.01*numpy.radians(1.0/3600.0)])
        dec = numpy.array([numpy.radians(self.obs_metadata.unrefractedDec) - 2.02*numpy.radians(1.0/3600.0)])

        ra, dec = self.cat.correctCoordinates(ra, dec)

        xPupil = numpy.array([-0.000262243770])
        yPupil = numpy.array([0.000199467792])

        xx, yy = self.cat.calculateFocalPlaneCoordinates(xPupil = xPupil, yPupil = yPupil)
        xx, yy = self.cat.calculateFocalPlaneCoordinates(ra = ra, dec = dec)

        self.assertRaises(RuntimeError, self.cat.calculateFocalPlaneCoordinates)
        self.assertRaises(RuntimeError, self.cat.calculateFocalPlaneCoordinates, ra = ra, dec = dec,
                             xPupil = xPupil, yPupil = yPupil)

        xx, yy = self.cat.calculatePixelCoordinates(xPupil = xPupil, yPupil = yPupil)
        xx, yy = self.cat.calculatePixelCoordinates(ra = ra, dec = dec)

        self.assertRaises(RuntimeError, self.cat.calculatePixelCoordinates)
        self.assertRaises(RuntimeError, self.cat.calculatePixelCoordinates, xPupil = xPupil,
                           yPupil = yPupil, ra = ra, dec = dec)

        name = self.cat.findChipName(xPupil = xPupil, yPupil = yPupil)
        self.assertTrue(name[0] is not None)

        name = self.cat.findChipName(ra = ra, dec = dec)
        xtest, ytest = self.cat.calculatePupilCoordinates(ra, dec )
        self.assertTrue(name[0] is not None)

        self.assertRaises(RuntimeError, self.cat.findChipName)
        self.assertRaises(RuntimeError, self.cat.findChipName, xPupil = xPupil, yPupil = yPupil,
                  ra = ra, dec = dec)

        myCameraCoords = CameraCoords()
        self.assertRaises(RuntimeError, myCameraCoords.findChipName, ra=ra, dec=dec,
                          obs_metadata=self.obs_metadata, epoch=2000.0)
        self.assertRaises(RuntimeError, myCameraCoords.findChipName, ra=ra, dec=dec, epoch=2000.0,
                          camera=self.cat.camera)
        self.assertRaises(RuntimeError, myCameraCoords.findChipName, ra=ra, dec=dec, camera=self.cat.camera,
                          obs_metadata=self.obs_metadata)
        test = myCameraCoords.findChipName(ra=ra, dec=dec, camera=self.cat.camera, epoch=2000.0,
                                           obs_metadata=self.obs_metadata)

        self.assertRaises(RuntimeError, myCameraCoords.calculatePixelCoordinates, ra=ra, dec=dec,
                          obs_metadata=self.obs_metadata, epoch=2000.0)
        self.assertRaises(RuntimeError, myCameraCoords.calculatePixelCoordinates, ra=ra, dec=dec, epoch=2000.0,
                          camera=self.cat.camera)
        self.assertRaises(RuntimeError, myCameraCoords.calculatePixelCoordinates, ra=ra, dec=dec,
                          camera=self.cat.camera, obs_metadata=self.obs_metadata)
        test = myCameraCoords.calculatePixelCoordinates(ra=ra, dec=dec, camera=self.cat.camera,
                                                        obs_metadata=self.obs_metadata, epoch=2000.0)

        self.assertRaises(RuntimeError, myCameraCoords.calculateFocalPlaneCoordinates, ra=ra, dec=dec,
                          obs_metadata=self.obs_metadata, epoch=2000.0)
        self.assertRaises(RuntimeError, myCameraCoords.calculateFocalPlaneCoordinates, ra=ra, dec=dec,
                          epoch=2000.0, camera=self.cat.camera)
        self.assertRaises(RuntimeError, myCameraCoords.calculateFocalPlaneCoordinates, ra=ra, dec=dec,
                          camera=self.cat.camera, obs_metadata=self.obs_metadata)
        test = myCameraCoords.calculateFocalPlaneCoordinates(ra=ra, dec=dec, camera=self.cat.camera,
                                                             obs_metadata=self.obs_metadata, epoch=2000.0)

    def testClassMethods(self):
        self.cat.write_catalog("AstrometryTestCatalog.txt")

        dtype = [('id',int),('raPhoSim',float),('decPhoSim',float),('raObserved',float),
                 ('decObserved',float),('x_focal_nominal',float),('y_focal_nominal',float),
                 ('x_pupil',float),('y_pupil',float),('chipName',str,11),('xPix',float),
                 ('yPix',float),('xFocalPlane',float),('yFocalPlane',float)]

        baselineData = numpy.loadtxt('AstrometryTestCatalog.txt',dtype = dtype, delimiter = ';')

        pupilTest = self.cat.calculatePupilCoordinates(baselineData['raObserved'],
                                                 baselineData['decObserved'])

        for (xxtest, yytest, xx, yy) in \
                zip(pupilTest[0], pupilTest[1], baselineData['x_pupil'], baselineData['y_pupil']):
            self.assertAlmostEqual(xxtest,xx,6)
            self.assertAlmostEqual(yytest,yy,6)

        focalTest = self.cat.calculateFocalPlaneCoordinates(xPupil = pupilTest[0],
                                      yPupil = pupilTest[1])

        focalRa = self.cat.calculateFocalPlaneCoordinates(ra = baselineData['raObserved'],
                        dec = baselineData['decObserved'])

        for (xxtest, yytest, xxra, yyra, xx, yy) in \
                zip(focalTest[0], focalTest[1], focalRa[0], focalRa[1],
                        baselineData['xFocalPlane'], baselineData['yFocalPlane']):

            self.assertAlmostEqual(xxtest,xx,6)
            self.assertAlmostEqual(yytest,yy,6)
            self.assertAlmostEqual(xxra,xx,6)
            self.assertAlmostEqual(yyra,yy,6)

        pixTest = self.cat.calculatePixelCoordinates(xPupil = pupilTest[0], yPupil = pupilTest[1])
        pixTestRaDec = self.cat.calculatePixelCoordinates(ra = baselineData['raObserved'],
                                   dec = baselineData['decObserved'])

        for (xxtest, yytest, xxra, yyra, xx, yy) in \
                zip(pixTest[0], pixTest[1], pixTestRaDec[0], pixTestRaDec[1],
                           baselineData['xPix'], baselineData['yPix']):

            if not numpy.isnan(xx) and not numpy.isnan(yy):
                self.assertAlmostEqual(xxtest,xx,5)
                self.assertAlmostEqual(yytest,yy,5)
                self.assertAlmostEqual(xxra,xx,5)
                self.assertAlmostEqual(yyra,yy,5)
            else:
                self.assertTrue(numpy.isnan(xx))
                self.assertTrue(numpy.isnan(yy))
                self.assertTrue(numpy.isnan(xxra))
                self.assertTrue(numpy.isnan(yyra))
                self.assertTrue(numpy.isnan(xxtest))
                self.assertTrue(numpy.isnan(yytest))

        gnomonTest = self.cat.calculateGnomonicProjection(baselineData['raObserved'],
                             baselineData['decObserved'])
        for (xxtest, yytest, xx, yy) in \
                zip(gnomonTest[0], gnomonTest[1],
                    baselineData['x_focal_nominal'], baselineData['y_focal_nominal']):

            self.assertAlmostEqual(xxtest,xx,6)
            self.assertAlmostEqual(yytest,yy,6)

        nameTest = self.cat.findChipName(xPupil = pupilTest[0], yPupil = pupilTest[1])
        nameRA = self.cat.findChipName(ra = baselineData['raObserved'], dec = baselineData['decObserved'])

        for (ntest, nra, ncontrol) in zip(nameTest, nameRA, baselineData['chipName']):
            if ncontrol != 'None':
                self.assertEqual(ntest,ncontrol)
                self.assertEqual(nra,ncontrol)
            else:
                self.assertTrue(ntest is None)
                self.assertTrue(nra is None)

        if os.path.exists("AstrometryTestCatalog.txt"):
            os.unlink("AstrometryTestCatalog.txt")

    def testIndependentAstrometryMethods(self):
        """
        Test that calling applyMeanApparentPlace, applyMeanObservedPlace,
        correctCoordinates, with observation data specified by hand
        will result in the correct outputs
        """

        obs_metadata = makeObservationMetaData()
        self.assertFalse(obs_metadata.mjd==self.obs_metadata.mjd)
        self.assertFalse(obs_metadata.unrefractedRA==self.obs_metadata.unrefractedRA)
        self.assertFalse(obs_metadata.unrefractedDec==self.obs_metadata.unrefractedDec)
        self.assertFalse(obs_metadata.site.longitude==self.obs_metadata.site.longitude)
        self.assertFalse(obs_metadata.site.latitude==self.obs_metadata.site.latitude)
        testCat = testCatalog(self.starDBObject, obs_metadata=obs_metadata)
        ra, dec, pm_ra, pm_dec, parallax, v_rad = makeRandomSample()

        control = self.cat.applyMeanApparentPlace(ra, dec,
                                                  pm_ra=pm_ra, pm_dec=pm_dec, parallax=parallax,
                                                  v_rad=v_rad, MJD=obs_metadata.mjd)
        test = testCat.applyMeanApparentPlace(ra, dec,
                                              pm_ra=pm_ra, pm_dec=pm_dec, parallax=parallax,
                                              v_rad=v_rad)
        shouldBeWrong = self.cat.applyMeanApparentPlace(ra, dec,
                                                        pm_ra=pm_ra, pm_dec=pm_dec, parallax=parallax,
                                                        v_rad=v_rad)

        self.compareTestControlAndWrong(test, control, shouldBeWrong)

        control = self.cat.applyMeanObservedPlace(ra, dec, obs_metadata=obs_metadata)
        test = testCat.applyMeanObservedPlace(ra, dec)
        shouldBeWrong = self.cat.applyMeanObservedPlace(ra, dec)

        self.compareTestControlAndWrong(test, control, shouldBeWrong)

        control = self.cat.correctCoordinates(ra, dec, pm_ra=pm_ra, pm_dec=pm_dec, parallax=parallax,
                                              v_rad=v_rad, obs_metadata=obs_metadata)
        test = testCat.correctCoordinates(ra, dec, pm_ra=pm_ra, pm_dec=pm_dec, parallax=parallax,
                                          v_rad=v_rad)
        shouldBeWrong = self.cat.correctCoordinates(ra, dec, pm_ra=pm_ra, pm_dec=pm_dec, parallax=parallax,
                                                    v_rad=v_rad)

        self.compareTestControlAndWrong(test, control, shouldBeWrong)

    def testIndpendentPupilCoords(self):
        """
        Test that calling calculatePupilCoordinates, with observation data specified by and
        will result in the correct outputs
        """

        obs_metadata = makeObservationMetaData()
        self.assertFalse(obs_metadata.mjd==self.obs_metadata.mjd)
        self.assertFalse(obs_metadata.unrefractedRA==self.obs_metadata.unrefractedRA)
        self.assertFalse(obs_metadata.unrefractedDec==self.obs_metadata.unrefractedDec)
        self.assertFalse(obs_metadata.site.longitude==self.obs_metadata.site.longitude)
        self.assertFalse(obs_metadata.site.latitude==self.obs_metadata.site.latitude)
        testCat = testCatalog(self.starDBObject, obs_metadata=obs_metadata)
        ra, dec, pm_ra, pm_dec, parallax, v_rad = \
                          makeRandomSample(raCenter = numpy.radians(obs_metadata.unrefractedRA),
                                           decCenter = numpy.radians(obs_metadata.unrefractedDec),
                                           radius = 2.0)

        raObj, decObj = testCat.correctCoordinates(ra, dec)
        control = self.cat.calculatePupilCoordinates(raObj, decObj, obs_metadata=obs_metadata)
        test = testCat.calculatePupilCoordinates(raObj, decObj)
        shouldBeWrong = self.cat.calculatePupilCoordinates(raObj, decObj)

        self.compareTestControlAndWrong(test, control, shouldBeWrong)

    def testIndependentFindChipName(self):
        """
        Test that calling FindchipName independent of a catalog object works,
        i.e. that if a user specifies an ObservationMetaData by hand, the code
        will use that ObservationMetaData
        """

        obs_metadata = makeObservationMetaData()
        self.assertFalse(obs_metadata.mjd==self.obs_metadata.mjd)
        self.assertFalse(obs_metadata.unrefractedRA==self.obs_metadata.unrefractedRA)
        self.assertFalse(obs_metadata.unrefractedDec==self.obs_metadata.unrefractedDec)
        self.assertFalse(obs_metadata.site.longitude==self.obs_metadata.site.longitude)
        self.assertFalse(obs_metadata.site.latitude==self.obs_metadata.site.latitude)
        myCameraCoords = CameraCoords()

        #generate some random RA and Decs to find chips for
        nsamples = 100
        numpy.random.seed(32)
        raIn = numpy.array([numpy.radians(obs_metadata.unrefractedRA)])
        decIn = numpy.array([numpy.radians(obs_metadata.unrefractedDec)])
        raCenter, decCenter = myCameraCoords.correctCoordinates(raIn, decIn,
                                                                   epoch=2000.0, obs_metadata=obs_metadata)

        ra, dec, pm_ra, pm_dec, parallax, v_rad = \
                    makeRandomSample(raCenter=raCenter, decCenter=decCenter, radius = 0.0004)

        chipNamesControl = self.cat.findChipName(ra=ra, dec=dec, obs_metadata=obs_metadata)

        chipNamesTest = myCameraCoords.findChipName(ra=ra, dec=dec, epoch=self.cat.db_obj.epoch,
                                                    obs_metadata=obs_metadata,
                                                    camera = self.cat.camera)
        shouldBeWrong = self.cat.findChipName(ra=ra, dec=dec)

        self.compareTestControlAndWrong(chipNamesTest, chipNamesControl, shouldBeWrong)

        #now vary the epoch
        epoch = 1500.0
        raIn = numpy.array([numpy.radians(obs_metadata.unrefractedRA)])
        decIn = numpy.array([numpy.radians(obs_metadata.unrefractedDec)])
        raCenter, decCenter = myCameraCoords.correctCoordinates(raIn, decIn,
                                                                   epoch=epoch, obs_metadata=obs_metadata)

        ra, dec, pm_ra, pm_dec, parallax, v_rad = \
                    makeRandomSample(raCenter=raCenter, decCenter=decCenter, radius = 0.0004)

        chipNamesControl = self.cat.findChipName(ra=ra, dec=dec, obs_metadata=obs_metadata,
                                                 epoch=epoch)

        chipNamesTest = myCameraCoords.findChipName(ra=ra, dec=dec, epoch=epoch,
                                                    obs_metadata=obs_metadata,
                                                    camera=self.cat.camera)
        shouldBeWrong = self.cat.findChipName(ra=ra, dec=dec, epoch=epoch)

        self.compareTestControlAndWrong(chipNamesTest, chipNamesControl, shouldBeWrong)

    def testIndependentFocalPlaneCoordinates(self):
        """
        Test to make sure that calculateFocalPlaneCoordinates returns the correct answer
        when you pass in an obs_metadata by hand
        """

        obs_metadata = makeObservationMetaData()
        self.assertFalse(obs_metadata.mjd==self.obs_metadata.mjd)
        self.assertFalse(obs_metadata.unrefractedRA==self.obs_metadata.unrefractedRA)
        self.assertFalse(obs_metadata.unrefractedDec==self.obs_metadata.unrefractedDec)
        self.assertFalse(obs_metadata.site.longitude==self.obs_metadata.site.longitude)
        self.assertFalse(obs_metadata.site.latitude==self.obs_metadata.site.latitude)
        myCameraCoords = CameraCoords()

        #generate some random RA and Decs to find chips for
        nsamples = 100
        numpy.random.seed(32)
        raIn = numpy.array([numpy.radians(obs_metadata.unrefractedRA)])
        decIn = numpy.array([numpy.radians(obs_metadata.unrefractedDec)])
        raCenter, decCenter = myCameraCoords.correctCoordinates(raIn, decIn,
                                                                   epoch=2000.0, obs_metadata=obs_metadata)

        ra, dec, pm_ra, pm_dec, parallax, v_rad = \
                    makeRandomSample(raCenter=raCenter, decCenter=decCenter, radius = 0.0004)

        control = self.cat.calculateFocalPlaneCoordinates(ra=ra, dec=dec, obs_metadata=obs_metadata)
        test = myCameraCoords.calculateFocalPlaneCoordinates(ra=ra, dec=dec, obs_metadata=obs_metadata,
                                                             epoch=self.cat.db_obj.epoch, camera=self.cat.camera)
        shouldBeWrong = self.cat.calculateFocalPlaneCoordinates(ra=ra, dec=dec)

        self.compareTestControlAndWrong(control, test, shouldBeWrong)

    def testIndependentPixelCoordinates(self):
        """
        Test to make sure that calculateFocalPlaneCoordinates returns the correct answer
        when you pass in an obs_metadata by hand
        """

        obs_metadata = makeObservationMetaData()
        self.assertFalse(obs_metadata.mjd==self.obs_metadata.mjd)
        self.assertFalse(obs_metadata.unrefractedRA==self.obs_metadata.unrefractedRA)
        self.assertFalse(obs_metadata.unrefractedDec==self.obs_metadata.unrefractedDec)
        self.assertFalse(obs_metadata.site.longitude==self.obs_metadata.site.longitude)
        self.assertFalse(obs_metadata.site.latitude==self.obs_metadata.site.latitude)
        myCameraCoords = CameraCoords()

        #generate some random RA and Decs to find chips for
        nsamples = 100
        numpy.random.seed(32)
        raIn = numpy.array([numpy.radians(obs_metadata.unrefractedRA)])
        decIn = numpy.array([numpy.radians(obs_metadata.unrefractedDec)])
        raCenter, decCenter = myCameraCoords.correctCoordinates(raIn, decIn,
                                                                   epoch=2000.0, obs_metadata=obs_metadata)

        ra, dec, pm_ra, pm_dec, parallax, v_rad = \
                    makeRandomSample(raCenter=raCenter, decCenter=decCenter, radius = 0.0004)

        control = self.cat.calculatePixelCoordinates(ra=ra, dec=dec, obs_metadata=obs_metadata)
        test = myCameraCoords.calculatePixelCoordinates(ra=ra, dec=dec, obs_metadata=obs_metadata,
                                                             epoch=self.cat.db_obj.epoch, camera=self.cat.camera)
        shouldBeWrong = self.cat.calculatePixelCoordinates(ra=ra, dec=dec)

        self.compareTestControlAndWrong(test, control, shouldBeWrong)



    def testAngularSeparation(self):
        arg1 = 7.853981633974482790e-01
        arg2 = 3.769911184307751517e-01
        arg3 = 5.026548245743668986e+00
        arg4 = -6.283185307179586232e-01

        output=self.cat.angularSeparation(arg1,arg2,arg3,arg4)

        self.assertAlmostEqual(output,2.162615946398791955e+00,10)

    def testRotationMatrixFromVectors(self):
        v1=numpy.zeros((3),dtype=float)
        v2=numpy.zeros((3),dtype=float)
        v3=numpy.zeros((3),dtype=float)

        v1[0]=-3.044619987218469825e-01
        v2[0]=5.982190522311925385e-01
        v1[1]=-5.473550908956383854e-01
        v2[1]=-5.573565912346714057e-01
        v1[2]=7.795545496018386755e-01
        v2[2]=-5.757495946632366079e-01

        output=self.cat.rotationMatrixFromVectors(v1,v2)

        for i in range(3):
            for j in range(3):
                v3[i]+=output[i][j]*v1[j]

        for i in range(3):
            self.assertAlmostEqual(v3[i],v2[i],7)

    def testApplyPrecession(self):

        ra=numpy.zeros((3),dtype=float)
        dec=numpy.zeros((3),dtype=float)

        ra[0]=2.549091039839124218e+00
        dec[0]=5.198752733024248895e-01
        ra[1]=8.693375673649429425e-01
        dec[1]=1.038086165642298164e+00
        ra[2]=7.740864769302191473e-01
        dec[2]=2.758053025017753179e-01

        #The MJD kwarg in applyPrecession below is a hold-over from
        #a misunderstanding in the API for the pal.prenut() back
        #when we generated the test data.  We passed a julian epoch
        #(in years) when PAL actually wanted an MJD.  The underlying
        #code has been fixed.  This test still passes a julian
        #epoch so that it will give the same results as the control
        #SLALIB run.
        output=self.cat.applyPrecession(ra,dec, MJD=pal.epj(2000.0))

        self.assertAlmostEqual(output[0][0],2.514361575034799401e+00,6)
        self.assertAlmostEqual(output[1][0], 5.306722463159389003e-01,6)
        self.assertAlmostEqual(output[0][1],8.224493314855578774e-01,6)
        self.assertAlmostEqual(output[1][1],1.029318353760459104e+00,6)
        self.assertAlmostEqual(output[0][2],7.412362765815005972e-01,6)
        self.assertAlmostEqual(output[1][2],2.662034339930458571e-01,6)

    def testApplyProperMotion(self):

        ra=numpy.zeros((3),dtype=float)
        dec=numpy.zeros((3),dtype=float)
        pm_ra=numpy.zeros((3),dtype=float)
        pm_dec=numpy.zeros((3),dtype=float)
        parallax=numpy.zeros((3),dtype=float)
        v_rad=numpy.zeros((3),dtype=float)

        ra[0]=2.549091039839124218e+00
        dec[0]=5.198752733024248895e-01
        pm_ra[0]=-8.472633255615005918e-05
        pm_dec[0]=-5.618517146980475171e-07
        parallax[0]=9.328946209650547383e-02
        v_rad[0]=3.060308412186171267e+02

        ra[1]=8.693375673649429425e-01
        dec[1]=1.038086165642298164e+00
        pm_ra[1]=-5.848962163813087908e-05
        pm_dec[1]=-3.000346282603337522e-05
        parallax[1]=5.392364722571952457e-02
        v_rad[1]=4.785834687356999098e+02

        ra[2]=7.740864769302191473e-01
        dec[2]=2.758053025017753179e-01
        pm_ra[2]=5.904070507320858615e-07
        pm_dec[2]=-2.958381482198743105e-05
        parallax[2]=2.172865273161764255e-02
        v_rad[2]=-3.225459751425886452e+02

        ep=2.001040286039033845e+03

        #This test passes pm_dec/numpy.cos(dec) because that is the input that
        #was used when the baseline data was generated with SLALIB
        output=self.cat.applyProperMotion(ra,dec,pm_ra,pm_dec/numpy.cos(dec),
                                          arcsecToRadians(parallax),v_rad,EP0=ep)

        self.assertAlmostEqual(output[0][0],2.549309127917495754e+00,6)
        self.assertAlmostEqual(output[1][0],5.198769294314042888e-01,6)
        self.assertAlmostEqual(output[0][1],8.694881589882680339e-01,6)
        self.assertAlmostEqual(output[1][1],1.038238225568303363e+00,6)
        self.assertAlmostEqual(output[0][2],7.740849573146946216e-01,6)
        self.assertAlmostEqual(output[1][2],2.758844356561930278e-01,6)


    def testApplyMeanApparentPlace(self):
        ra=numpy.zeros((3),dtype=float)
        dec=numpy.zeros((3),dtype=float)
        pm_ra=numpy.zeros((3),dtype=float)
        pm_dec=numpy.zeros((3),dtype=float)
        parallax=numpy.zeros((3),dtype=float)
        v_rad=numpy.zeros((3),dtype=float)


        ra[0]=2.549091039839124218e+00
        dec[0]=5.198752733024248895e-01
        pm_ra[0]=-8.472633255615005918e-05
        pm_dec[0]=-5.618517146980475171e-07
        parallax[0]=9.328946209650547383e-02
        v_rad[0]=3.060308412186171267e+02

        ra[1]=8.693375673649429425e-01
        dec[1]=1.038086165642298164e+00
        pm_ra[1]=-5.848962163813087908e-05
        pm_dec[1]=-3.000346282603337522e-05
        parallax[1]=5.392364722571952457e-02
        v_rad[1]=4.785834687356999098e+02

        ra[2]=7.740864769302191473e-01
        dec[2]=2.758053025017753179e-01
        pm_ra[2]=5.904070507320858615e-07
        pm_dec[2]=-2.958381482198743105e-05
        parallax[2]=2.172865273161764255e-02
        v_rad[2]=-3.225459751425886452e+02


        #hack because this is how the SLALIB baseline tests were run
        for i in range(3):
            pm_dec[i]=pm_dec[i]/numpy.cos(dec[i])

        ep=2.001040286039033845e+03
        mjd=2.018749109074271473e+03
        obs_metadata=ObservationMetaData(mjd=mjd,
                                     boundType='circle',
                                     boundLength=0.05,
                                     phoSimMetaData=self.metadata)

        cat = testCatalog(self.starDBObject, obs_metadata=obs_metadata)

        output=cat.applyMeanApparentPlace(ra,dec,pm_ra = pm_ra,pm_dec = pm_dec,
              parallax = arcsecToRadians(parallax),v_rad = v_rad, Epoch0=ep)

        self.assertAlmostEqual(output[0][0],2.525858337335585180e+00,6)
        self.assertAlmostEqual(output[1][0],5.309044018653210628e-01,6)
        self.assertAlmostEqual(output[0][1],8.297492370691380570e-01,6)
        self.assertAlmostEqual(output[1][1],1.037400063009288331e+00,6)
        self.assertAlmostEqual(output[0][2],7.408639821342507537e-01,6)
        self.assertAlmostEqual(output[1][2],2.703229189890907214e-01,6)

    def testApplyMeanObservedPlace(self):
        """
        Note: this routine depends on Aopqk which fails if zenith distance
        is too great (or, at least, it won't warn you if the zenith distance
        is greater than pi/2, in which case answers won't make sense)
        """

        ra=numpy.zeros((3),dtype=float)
        dec=numpy.zeros((3),dtype=float)

        #we need to pass wv as the effective wavelength for methods that
        #calculate refraction because, when the control SLALIB runs were
        #done we misinterpreted the units of wavelength to be Angstroms
        #rather than microns.
        wv = 5000.0

        ra[0]=2.549091039839124218e+00
        dec[0]=5.198752733024248895e-01
        ra[1]=4.346687836824714712e-01
        dec[1]=-5.190430828211490821e-01
        ra[2]=7.740864769302191473e-01
        dec[2]=2.758053025017753179e-01

        mjd=2.018749109074271473e+03
        obs_metadata=ObservationMetaData(mjd=mjd,
                                     boundType='circle',
                                     boundLength=0.05,
                                     phoSimMetaData=self.metadata)

        cat = testCatalog(self.starDBObject, obs_metadata=obs_metadata)

        output=cat.applyMeanObservedPlace(ra,dec, wavelength=wv)

        self.assertAlmostEqual(output[0][0],2.547475965605183745e+00,6)
        self.assertAlmostEqual(output[1][0],5.187045152602967057e-01,6)

        self.assertAlmostEqual(output[0][1],4.349858626308809040e-01,6)
        self.assertAlmostEqual(output[1][1],-5.191213875880701378e-01,6)

        self.assertAlmostEqual(output[0][2],7.743528611421227614e-01,6)
        self.assertAlmostEqual(output[1][2],2.755070101670137328e-01,6)

        output=cat.applyMeanObservedPlace(ra,dec,altAzHr=True, wavelength=wv)

        self.assertAlmostEqual(output[0][0],2.547475965605183745e+00,6)
        self.assertAlmostEqual(output[1][0],5.187045152602967057e-01,6)
        self.assertAlmostEqual(output[2][0],1.168920017932007643e-01,6)
        self.assertAlmostEqual(output[3][0],8.745379535264000692e-01,6)

        self.assertAlmostEqual(output[0][1],4.349858626308809040e-01,6)
        self.assertAlmostEqual(output[1][1],-5.191213875880701378e-01,6)
        self.assertAlmostEqual(output[2][1],6.766119585479937193e-01,6)
        self.assertAlmostEqual(output[3][1],4.433969998336554141e+00,6)

        self.assertAlmostEqual(output[0][2],7.743528611421227614e-01,6)
        self.assertAlmostEqual(output[1][2],2.755070101670137328e-01,6)
        self.assertAlmostEqual(output[2][2],5.275840601437552513e-01,6)
        self.assertAlmostEqual(output[3][2],5.479759580847959555e+00,6)

        output=cat.applyMeanObservedPlace(ra,dec,includeRefraction=False,
                                               wavelength=wv)

        self.assertAlmostEqual(output[0][0],2.549091783674975353e+00,6)
        self.assertAlmostEqual(output[1][0],5.198746844679964507e-01,6)

        self.assertAlmostEqual(output[0][1],4.346695674418772359e-01,6)
        self.assertAlmostEqual(output[1][1],-5.190436610150490626e-01,6)

        self.assertAlmostEqual(output[0][2],7.740875471580924705e-01,6)
        self.assertAlmostEqual(output[1][2],2.758055401087299296e-01,6)

        output=cat.applyMeanObservedPlace(ra,dec,includeRefraction=False,
                                               altAzHr=True, wavelength=wv)

        self.assertAlmostEqual(output[0][0],2.549091783674975353e+00,6)
        self.assertAlmostEqual(output[1][0],5.198746844679964507e-01,6)
        self.assertAlmostEqual(output[2][0],1.150652107618796299e-01,6)
        self.assertAlmostEqual(output[3][0],8.745379535264000692e-01,6)

        self.assertAlmostEqual(output[0][1],4.346695674418772359e-01,6)
        self.assertAlmostEqual(output[1][1],-5.190436610150490626e-01,6)
        self.assertAlmostEqual(output[2][1],6.763265401447272618e-01,6)
        self.assertAlmostEqual(output[3][1],4.433969998336554141e+00,6)

        self.assertAlmostEqual(output[0][2],7.740875471580924705e-01,6)
        self.assertAlmostEqual(output[1][2],2.758055401087299296e-01,6)
        self.assertAlmostEqual(output[2][2],5.271912536356709866e-01,6)
        self.assertAlmostEqual(output[3][2],5.479759580847959555e+00,6)

    def testMeanObservedPlace_NoRefraction(self):

        ra=numpy.zeros((3),dtype=float)
        dec=numpy.zeros((3),dtype=float)

        ra[0]=2.549091039839124218e+00
        dec[0]=5.198752733024248895e-01
        ra[1]=4.346687836824714712e-01
        dec[1]=-5.190430828211490821e-01
        ra[2]=7.740864769302191473e-01
        dec[2]=2.758053025017753179e-01

        mjd=2.018749109074271473e+03
        obs_metadata=ObservationMetaData(mjd=mjd,
                                     boundType='circle',
                                     boundLength=0.05,
                                     phoSimMetaData=self.metadata)

        cat = testCatalog(self.starDBObject, obs_metadata=obs_metadata)

        output=cat.applyMeanObservedPlace(ra,dec,altAzHr=True,
                 includeRefraction = False)

        self.assertAlmostEqual(output[0][0],2.549091783674975353e+00,6)
        self.assertAlmostEqual(output[1][0],5.198746844679964507e-01,6)
        self.assertAlmostEqual(output[0][1],4.346695674418772359e-01,6)
        self.assertAlmostEqual(output[1][1],-5.190436610150490626e-01,6)
        self.assertAlmostEqual(output[0][2],7.740875471580924705e-01,6)
        self.assertAlmostEqual(output[1][2],2.758055401087299296e-01,6)
        self.assertAlmostEqual(output[2][2],5.271914342095551653e-01,6)
        self.assertAlmostEqual(output[3][2],5.479759402150099490e+00,6)

    def testRefractionCoefficients(self):
        output=self.cat.refractionCoefficients(wavelength=5000.0)

        self.assertAlmostEqual(output[0],2.295817926320665320e-04,6)
        self.assertAlmostEqual(output[1],-2.385964632924575670e-07,6)

    def testApplyRefraction(self):
        coeffs=self.cat.refractionCoefficients(wavelength = 5000.0)

        output=self.cat.applyRefraction(0.25*numpy.pi,coeffs[0],coeffs[1])

        self.assertAlmostEqual(output,7.851689251070859132e-01,6)

    def testCalcLast(self):

        arg1=2.004031374869656474e+03
        arg2=10

        output=self.cat.calcLast(arg1,arg2)
        self.assertAlmostEqual(output,1.662978602873423029e+00,5)

    def testEquatorialToHorizontal(self):
        arg1=2.549091039839124218e+00
        arg2=5.198752733024248895e-01
        arg3=2.004031374869656474e+03
        output=self.cat.equatorialToHorizontal(arg1,arg2,arg3)

        self.assertAlmostEqual(output[0],4.486633480937949336e-01,5)
        self.assertAlmostEqual(output[1],5.852620488358430961e+00,5)

    def testParalacticAngle(self):
        arg1=1.507444663929565554e+00
        arg2=-4.887258694875344922e-01

        output=self.cat.paralacticAngle(arg1,arg2)

        self.assertAlmostEqual(output,1.381600229503358701e+00,6)

    def testPixelPos(self):
        for chunk, chunkMap in self.cat.iter_catalog_chunks():
            self.assertTrue(numpy.all(numpy.isfinite(self.cat.column_by_name('x_pupil'))))
            self.assertTrue(numpy.all(numpy.isfinite(self.cat.column_by_name('y_pupil'))))
            for x, y, cname in zip(self.cat.column_by_name('xPix'), self.cat.column_by_name('yPix'),
                                   self.cat.column_by_name('chipName')):
                if cname is None:
                    #make sure that x and y are not set if the object doesn't land on a chip
                    self.assertTrue(not numpy.isfinite(x) and not numpy.isfinite(y))
                else:
                    #make sure the pixel positions are inside the detector bounding box.
                    self.assertTrue(afwGeom.Box2D(self.cat.camera[cname].getBBox()).contains(afwGeom.Point2D(x,y)))


    def testParallax(self):
        """
        This test will output a catalog of uncorrected and corrected (astrometrically)
        ra and dec.  It will also output the quantities (proper motion, radial velocity,
        and parallax) needed to apply the astrometric corrections.  It will then run the
        catalog through PALPY and verify that the catalog generating code correctly applied
        the astrometric corrections.
        """

        #create and write a catalog that performs astrometric transformations
        #on a cartoon star database
        cat = parallaxTestCatalog(self.starDBObject, obs_metadata=self.obs_metadata)
        parallaxName = 'parallaxCatalog.sav'
        cat.write_catalog(parallaxName)

        data = numpy.genfromtxt(parallaxName,delimiter=',')
        epoch = cat.db_obj.epoch
        mjd = cat.obs_metadata.mjd
        prms = pal.mappa(epoch, mjd)
        for vv in data:
            #run the PALPY routines that actuall do astrometry `by hand' and compare
            #the results to the contents of the catalog
            ra0 = numpy.radians(vv[0])
            dec0 = numpy.radians(vv[1])
            pmra = numpy.radians(vv[4])
            pmdec = numpy.radians(vv[5])
            rv = vv[6]
            px = vv[7]
            ra_apparent, dec_apparent = pal.mapqk(ra0, dec0, pmra, pmdec, px, rv, prms)
            ra_apparent = numpy.array([ra_apparent])
            dec_apparent = numpy.array([dec_apparent])
            raObserved, decObserved = cat.applyMeanObservedPlace(ra_apparent, dec_apparent,
                                                                 obs_metadata=cat.obs_metadata)

            self.assertAlmostEqual(raObserved[0],numpy.radians(vv[2]),10)
            self.assertAlmostEqual(decObserved[0],numpy.radians(vv[3]),10)

        if os.path.exists(parallaxName):
            os.unlink(parallaxName)

def suite():
    utilsTests.init()
    suites = []
    suites += unittest.makeSuite(astrometryUnitTest)
    return unittest.TestSuite(suites)

def run(shouldExit = False):
    utilsTests.run(suite(),shouldExit)

if __name__ == "__main__":
    run(True)
